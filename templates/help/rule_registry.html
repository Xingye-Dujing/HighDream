<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>RuleRegistry - 规则注册器文档</title>
    <link rel="stylesheet" href="/static/help.css"/>
</head>
<body>
<div id="help-container">
    <ul class="header">
        <li>
            <a href="/">HighDream Notebook</a>
        </li>
        <li>
            <a href="/help">帮助文档</a>
        </li>
    </ul>

    <h1><strong>RuleRegistry</strong> (core/rule_registry.py)</h1>

    <p>
        符号表达式的规则系统，管理规则的注册、匹配和调度。它实现了灵活的规则驱动架构，支持各种数学运算的自动变换。
    </p>

    <div class="warning">
        <p>
            <strong>注意:</strong>&nbsp;&nbsp;
            出现的所有图中，箭头的方向无实际意义，上面的文字所指可能是前对后，也可能是后对前
        </p>
    </div>

    <h2 id="class-overview">一.&nbsp;&nbsp;类概述</h2>
    <p>
        RuleRegistry 实现了基于规则的模式匹配和表达式转换系统，主要功能包括：
    </p>
    <ul>
        <li><strong>规则管理</strong>：注册、组织和调度表达式转换规则</li>
        <li><strong>匹配系统</strong>：通过匹配器函数确定适用的规则</li>
        <li><strong>动态调度</strong>：根据表达式类型自动选择最佳规则</li>
        <li><strong>工厂模式</strong>：提供常用规则和匹配器的快速创建方法</li>
    </ul>

    <p>它与其它类的关系如下：</p>
    <img src="/static/images/system_architecture_1.svg"/>

    <h2 id="design-principles">二.&nbsp;&nbsp;设计原则</h2>
    <ul>
        <li>
            <strong>分离关注点</strong
            >：规则处理逻辑与匹配逻辑彻底分离，但造成了一定的性能损耗
        </li>
        <li><strong>可扩展性</strong>：支持动态添加新规则和匹配器</li>
        <li><strong>类型安全</strong>：使用类型注解确保接口一致性</li>
    </ul>
    <div class="warning">
        <strong>注意：</strong
        >规则函数无需检测此规则对表达式是否可用，直接变换表达式即可。因为只要进入了某一个规则函数，则说明已通过对应匹配器函数的检测，
    </div>

    <h2 id="core-concepts">三.&nbsp;&nbsp;核心概念</h2>
    <h3>1.&nbsp;&nbsp;上下文字典 (RuleContext)</h3>
    <p>存储执行计算需要的参数，比如变量、极限方向等</p>
    <div class="method-signature">
        RuleContext: Dict[str, Union[Symbol, Expr, str]]
    </div>

    <h3>2.&nbsp;&nbsp;操作类型 (Operation)</h3>
    <p>
        <strong>Sympy 的数学运算类型</strong>，如 Derivative, Determinant,
        Integral, Limit 等。
    </p>

    <h3>3.&nbsp;&nbsp;规则函数 (RuleFunction)</h3>
    <p>
        执行实际表达式转换的函数，接收表达式和上下文字典，返回转换结果和解释说明。
    </p>
    <div class="method-signature">
        RuleFunction: Callable[[Expr, RuleContext], Optional[Tuple[Expr, str]]]
    </div>
    <div class="warning">
        <p>
            <strong>注意:</strong>
            除非该步可以直接得到结果，否则返回的 Expr 应包括 Operation
            对象。此外，整数要以 Sympy 的 Integer 对象返回，<strong
        >返回 Pyhon 的 int 对象将报错</strong
        >。
        </p>
    </div>

    <h3>4.&nbsp;&nbsp;匹配器函数 (MatcherFunction)</h3>
    <p>判断表达式是否适用特定规则的函数，返回规则名称或 None。</p>
    <div class="method-signature">
        MatcherFunction: Callable[[Expr, RuleContext], Optional[str]]
    </div>

    <h2 id="architecture">四.&nbsp;&nbsp;系统架构</h2>
    <h4>1.&nbsp;&nbsp;工作流程</h4>
    <ul>
        <li><strong>注册阶段</strong>：规则和匹配器被注册到 RuleRegistry</li>
        <li><strong>匹配阶段</strong>：对输入表达式运行所有匹配器</li>
        <li><strong>执行阶段</strong>：调用匹配成功的规则函数</li>
        <li><strong>返回阶段</strong>：返回转换后的表达式和解释</li>
    </ul>

    <h4>2.&nbsp;&nbsp;数据流</h4>
    <img src="/static/images/rule_registry.svg"/>

    <h2 id="attributes">五.&nbsp;&nbsp;属性</h2>
    <table class="parameter-table">
        <thead>
        <tr>
            <th>属性名</th>
            <th>类型</th>
            <th>描述</th>
            <th>访问级别</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <td>_rules</td>
            <td>RuleDict</td>
            <td>存储所有已注册的规则函数，键为规则名称，值为规则函数</td>
            <td>私有</td>
        </tr>
        <tr>
            <td>_matchers</td>
            <td>MatcherList</td>
            <td>存储所有已注册的匹配器函数，按注册顺序排列</td>
            <td>私有</td>
        </tr>
        </tbody>
    </table>

    <div class="warning">
        <p>
            <strong>注意:</strong>
            匹配器列表的元素顺序保持注册顺序，即注册顺序决定了规则匹配的优先级。
        </p>
    </div>

    <h2 id="methods">六.&nbsp;&nbsp;方法</h2>

    <h3>1.&nbsp;&nbsp;初始化方法</h3>

    <div class="method-signature">__init__(self) -> None</div>
    <p>初始化规则注册器实例，创建空的规则字典和匹配器列表。</p>

    <h3>2.&nbsp;&nbsp;注册方法</h3>

    <div class="method-signature">
        _register_rule(self, name: str, func: RuleFunction) -> None
    </div>
    <p>通过名称注册单个规则函数。</p>
    <p><strong>参数:</strong></p>
    <table class="parameter-table">
        <thead>
        <tr>
            <th>参数名</th>
            <th>类型</th>
            <th>描述</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <td>name</td>
            <td>str</td>
            <td>规则的唯一标识符</td>
        </tr>
        <tr>
            <td>func</td>
            <td>RuleFunction</td>
            <td>规则函数，接收表达式和上下文字典，返回转换结果</td>
        </tr>
        </tbody>
    </table>
    <div class="warning">
        <p><strong>注意:</strong> 如果同名规则已存在，将被新注册的规则覆盖。</p>
    </div>

    <div class="method-signature">
        _register_matcher(self, matcher: MatcherFunction) -> None
    </div>
    <p>注册单个匹配器函数。</p>
    <p><strong>参数:</strong></p>
    <table class="parameter-table">
        <thead>
        <tr>
            <th>参数名</th>
            <th>类型</th>
            <th>描述</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <td>matcher</td>
            <td>MatcherFunction</td>
            <td>匹配器函数，检测表达式是否适用特定规则</td>
        </tr>
        </tbody>
    </table>

    <div class="method-signature">
        _register_all_rules(self, rules: RuleDict) -> None
    </div>
    <p>批量注册规则字典中的所有规则。</p>
    <p><strong>参数:</strong></p>
    <table class="parameter-table">
        <thead>
        <tr>
            <th>参数名</th>
            <th>类型</th>
            <th>描述</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <td>rules</td>
            <td>RuleDict</td>
            <td>规则字典，键值对为规则名称到规则函数的映射</td>
        </tr>
        </tbody>
    </table>

    <div class="method-signature">
        _register_all_matchers(self, matchers: MatcherList) -> None
    </div>
    <p>批量注册匹配器列表中的所有匹配器。</p>
    <p><strong>参数:</strong></p>
    <table class="parameter-table">
        <thead>
        <tr>
            <th>参数名</th>
            <th>类型</th>
            <th>描述</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <td>matchers</td>
            <td>MatcherList</td>
            <td>匹配器函数列表</td>
        </tr>
        </tbody>
    </table>

    <div class="method-signature">
        register_all(self, rules: RuleDict, matchers: MatcherList) -> None
    </div>
    <p>一次性注册所有规则和匹配器，这是核心注册接口。</p>
    <p><strong>参数:</strong></p>
    <table class="parameter-table">
        <thead>
        <tr>
            <th>参数名</th>
            <th>类型</th>
            <th>描述</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <td>rules</td>
            <td>RuleDict</td>
            <td>要注册的规则字典</td>
        </tr>
        <tr>
            <td>matchers</td>
            <td>MatcherList</td>
            <td>要注册的匹配器列表</td>
        </tr>
        </tbody>
    </table>

    <h3>3.&nbsp;&nbsp;规则匹配方法</h3>

    <div class="method-signature">
        get_applicable_rules(self, expr: Expr, context: RuleContext, ) ->
        RuleList
    </div>
    <p>获取适用于给定表达式的所有规则函数。</p>
    <p><strong>参数:</strong></p>
    <table class="parameter-table">
        <thead>
        <tr>
            <th>参数名</th>
            <th>类型</th>
            <th>描述</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <td>expr</td>
            <td>Expr</td>
            <td>要匹配的 SymPy 表达式</td>
        </tr>
        <tr>
            <td>context</td>
            <td>RuleContext</td>
            <td>用于计算的上下文字典，包含变量等信息</td>
        </tr>
        </tbody>
    </table>
    <p><strong>返回值:</strong> RuleList - 适用的规则函数列表</p>
    <p><strong>匹配流程:</strong></p>
    <ol>
        <li>遍历所有已注册的匹配器</li>
        <li>对每个匹配器，使用表达式和上下文字典进行检测</li>
        <li>如果匹配器返回规则名称且在规则字典中存在，则添加对应规则</li>
        <li>返回所有匹配成功的规则函数列表</li>
    </ol>

    <h3 id="factory-methods">4.&nbsp;&nbsp;工厂方法</h3>

    <div class="method-signature">
        @staticmethod create_common_rule(operation: Operation, func_name: str)
        -> RuleFunction
    </div>
    <p>创建通用规则函数的工厂方法，适用于常见函数类型的变换规则。</p>
    <p><strong>参数:</strong></p>
    <table class="parameter-table">
        <thead>
        <tr>
            <th>参数名</th>
            <th>类型</th>
            <th>描述</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <td>operation</td>
            <td>Operation</td>
            <td>数学操作类型（如 Derivative、Integral 等）</td>
        </tr>
        <tr>
            <td>func_name</td>
            <td>str</td>
            <td>函数名称，用于生成解释文本</td>
        </tr>
        </tbody>
    </table>
    <p><strong>返回值:</strong> RuleFunction - 生成的规则函数</p>
    <p><strong>生成的规则函数行为:</strong></p>
    <ul>
        <li>对输入表达式执行指定的数学操作</li>
        <li>计算结果并生成 LaTeX 格式的解释说明</li>
        <li>返回结果和解释的元组</li>
    </ul>

    <div class="method-signature">
        @staticmethod create_common_matcher(func: Union[exp, log,
        InverseTrigonometricFunction, TrigonometricFunction]) -> MatcherFunction
    </div>
    <p>创建通用匹配器函数的工厂方法，用于检测特定函数类型。</p>
    <p><strong>参数:</strong></p>
    <table class="parameter-table">
        <thead>
        <tr>
            <th>参数名</th>
            <th>类型</th>
            <th>描述</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <td>func</td>
            <td>
                Union[exp, log, InverseTrigonometricFunction,
                TrigonometricFunction]
            </td>
            <td>要匹配的函数类型</td>
        </tr>
        </tbody>
    </table>
    <p><strong>返回值:</strong> MatcherFunction - 生成的匹配器函数</p>
    <p><strong>生成的匹配器函数行为:</strong></p>
    <ul>
        <li>检查表达式是否为指定函数类型</li>
        <li>检查函数的参数是否与上下文字典中的变量匹配</li>
        <li>如果匹配成功，返回函数名称的小写形式作为规则标识符</li>
    </ul>

    <h2>七.&nbsp;&nbsp;规则设计指南</h2>
    <p>
        1.&nbsp;&nbsp;<strong>单一职责</strong>：每个规则应专注于一种特定的表达式模式
    </p>
    <p>
        2.&nbsp;&nbsp;<strong>明确匹配条件</strong>：匹配器应该精确描述适用条件，避免过度匹配
    </p>
    <p>
        3.&nbsp;&nbsp;<strong>有意义的解释</strong>：规则应提供清晰的教学性解释，便于理解计算过程
    </p>
    <p>
        4.&nbsp;&nbsp;<strong>步骤最优考虑</strong>：将处理特殊情况的规则放在匹配器列表前面，确保使用当前最优变换
    </p>

    <h2>八.&nbsp;&nbsp;注意事项</h2>
    <p>
        1.&nbsp;&nbsp;<strong>名称字符串一致</strong>：确保规则名称在匹配器和规则字典中保持一致
    </p>
    <p>
        2.&nbsp;&nbsp;<strong>返回 None</strong
    >：当无法处理表达式时，规则函数应返回 None，而不是抛出异常
    </p>
    <p>
        3.&nbsp;&nbsp;<strong>规则的优先级</strong>：特殊规则应先于通用规则注册
    </p>
    <p>
        4.&nbsp;&nbsp;<strong>边界检测</strong>：测试规则在各种边界条件下的行为
    </p>
    <p>
        5.&nbsp;&nbsp;<strong>避免重复检测</strong>：规则函数无需检测此规则对表达式是否可用，因为只要进入了某一个规则函数，则说明已通过对应匹配器函数的检测
    </p>

    <h2>九.&nbsp;&nbsp;调试技巧</h2>
    <p>1.&nbsp;&nbsp;在此类中调试</p>
    <div class="core-area">
        在 get_applicable_rules 方法中添加 print(applicable) 语句以得到匹配结果
    </div>
    <p>2.&nbsp;&nbsp;在调用它的类中调试</p>
    <div class="core-area">
        在 BaseCalculator 类的 _apply_rule 方法中启用 print(f"rule:
        {rule.__name__}") 语句
    </div>
</div>
</body>
</html>
