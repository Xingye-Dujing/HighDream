<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>BaseCalculator - 符号计算器基类文档</title>
    <link rel="stylesheet" href="/static/help.css" />
  </head>
  <body>
    <div id="help-container">
      <ul class="header">
        <li>
          <a href="/">HighDream Notebook</a>
        </li>
        <li>
          <a href="/help">帮助文档</a>
        </li>
      </ul>

      <h1><strong>BaseCalculator</strong> (core/base_calculator.py)</h1>

      <p>
        符号计算器的抽象基类，为微分、积分、极限和行列式计算器提供统一的框架和基础功能。它实现了规则驱动的逐步计算。
      </p>

      <div class="warning">
        <p>
          <strong>注意:</strong>&nbsp;&nbsp; 该类只能继承使用，不能直接使用。
        </p>
      </div>

      <div class="warning">
        <p>
          <strong>注意:</strong>&nbsp;&nbsp;
          出现的所有图中，箭头的方向无实际意义，上面的文字所指可能是前对后，也可能是后对前
        </p>
      </div>

      <h2 id="class-overview">一.&nbsp;&nbsp;类概述</h2>
      <p>
        BaseCalculator
        是一个抽象基类，定义了符号表达式逐步计算器的核心架构。它采用以下关键技术：
      </p>
      <ul>
        <li>
          <strong>规则注册系统</strong>：通过 RuleRegistry 管理表达式变换规则
        </li>
        <li><strong>步骤生成器</strong>：记录和展示计算过程的每一步</li>
        <li><strong>缓存机制</strong>：优化重复计算，提高性能</li>
        <li>
          <strong>广度优先搜索(BFS)</strong
          >：使用队列存储每步待处理的表达式，确保计算的逻辑顺序
        </li>
      </ul>

      <p>它与其它类的关系如下：</p>
      <img src="/static/images/system_architecture_1.svg" alt="架构一" />

      <h2 id="design-principles">二.&nbsp;&nbsp;设计原则</h2>
      <ul>
        <li>
          <strong>可扩展性</strong>：通过继承和重写方法支持不同类型的计算器
        </li>
        <li>
          <strong>模块化</strong
          >：将规则管理、步骤生成、缓存等功能分离为独立组件
        </li>
        <li>
          <strong>性能优化</strong>：使用 LRU 缓存和表达式缓存减少重复计算
        </li>
        <li><strong>灵活性</strong>：支持多种输出格式（列表、LaTeX）</li>
      </ul>

      <h2 id="attributes">三.&nbsp;&nbsp;属性</h2>
      <table class="parameter-table">
        <thead>
          <tr>
            <th>属性名</th>
            <th>类型</th>
            <th>描述</th>
            <th>访问级别</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>_rule_registry</td>
            <td>RuleRegistry</td>
            <td>规则注册器实例，管理与规则和匹配器相关的操作</td>
            <td>私有</td>
          </tr>
          <tr>
            <td>step_generator</td>
            <td>BaseStepGenerator</td>
            <td>步骤生成器实例，负责记录和管理计算步骤</td>
            <td>公共</td>
          </tr>
          <tr>
            <td>processed</td>
            <td>set</td>
            <td>记录已处理的表达式，防止在 BFS 过程中陷入死循环</td>
            <td>公共</td>
          </tr>
          <tr>
            <td>cache</td>
            <td>dict</td>
            <td>缓存表达式到对应操作对象（Derivative/Integral等）的转换结果</td>
            <td>公共</td>
          </tr>
          <tr>
            <td>operation</td>
            <td>Operation</td>
            <td>
              计算操作类型（如 Derivative, Integral），由子类在
              init_key_property 中初始化
            </td>
            <td>受保护</td>
          </tr>
          <tr>
            <td>rule_dict</td>
            <td>RuleDict</td>
            <td>规则字典，包含所有可用的表达式变换规则</td>
            <td>受保护</td>
          </tr>
          <tr>
            <td>matcher_list</td>
            <td>MatcherList</td>
            <td>匹配器列表，用于确定应用哪些规则及应用顺序</td>
            <td>受保护</td>
          </tr>
        </tbody>
      </table>

      <h2 id="methods">四.&nbsp;&nbsp;方法</h2>

      <h3>1.&nbsp;&nbsp;初始化与状态管理</h3>

      <div class="method-signature">__init__(self) -> None</div>
      <p>初始化计算器实例，设置规则注册器、步骤生成器、缓存等核心组件。</p>
      <p><strong>执行流程:</strong></p>
      <ol>
        <li>创建 RuleRegistry 和 BaseStepGenerator 实例</li>
        <li>初始化 processed 集合和 cache 字典</li>
        <li>调用 init_key_property 初始化关键属性</li>
        <li>验证属性是否正确初始化</li>
        <li>注册所有规则和匹配器</li>
      </ol>
      <img
        src="/static/images/base_calculator/bc_init.svg"
        alt="bc_init"
        style="max-width: 100%"
      />

      <div class="method-signature">
        @abstractmethod init_key_property(self) -> None
      </div>
      <p>
        <strong>抽象方法</strong> -
        必须在子类中实现。用于初始化计算器的关键属性：
      </p>
      <img
        src="/static/images/base_calculator/bc_init_key.svg"
        alt="bc_init_key_property"
        style="max-width: 100%"
      />

      <div class="method-signature">_validate_properties(self) -> None</div>
      <p>验证所有必需属性是否已在 init_key_property 中正确初始化。</p>
      <div class="warning">
        <p>
          <strong>注意:</strong> 如果必需属性未初始化，将抛出 ValueError 异常。
        </p>
      </div>

      <div class="method-signature">_initialize_rules(self) -> None</div>
      <p>通过 RuleRegistry 注册所有规则和匹配器函数。</p>

      <div class="method-signature">reset_process(self) -> None</div>
      <p>
        重置计算器状态(清除已处理表达式集合并重置步骤生成器)，为新的计算做准备。
      </p>

      <h3>2.&nbsp;&nbsp;核心计算方法</h3>

      <div class="method-signature">
        _do_compute(self, expr: str, operation: Operation, **context: Context)
        -> None
      </div>
      <p>广度优先搜索(BFS)实现逐步的符号计算。</p>
      <p><strong>参数:</strong></p>
      <ul>
        <li><code>expr</code>: 要计算的表达式字符串</li>
        <li><code>operation</code>: 要执行的操作类型</li>
        <li><code>**context</code>: 计算上下文（如变量、极限方向等）</li>
      </ul>
      <p><strong>算法流程:</strong></p>
      <ol>
        <li>重置计算器状态</li>
        <li>将输入字符串转换为 SymPy 表达式</li>
        <li>尝试简化表达式</li>
        <li>使用 BFS 遍历表达式树</li>
        <li>对每个子表达式应用规则</li>
        <li>记录每一步的计算结果</li>
        <li>最终化简和后处理</li>
      </ol>
      <img
        src="/static/images/base_calculator/bc_do_compute.svg"
        alt="bc_do_compute"
      />

      <div class="method-signature">
        _compute(self, expr: str, **context: Context) -> None
      </div>
      <p>
        逐步计算表达式的包装方法，会使用实例的 operation 属性。LimitCalculator
        将大幅度重构它。
      </p>

      <h3>3.&nbsp;&nbsp;规则应用方法</h3>

      <div class="method-signature">
        _apply_rule(self, expr: Expr, operation: Operation, **context: Context)
        -> Tuple[Expr, str]
      </div>
      <p>应用最适合的规则来变换表达式，并返回结果和解释说明。</p>
      <p><strong>返回值:</strong> 包含变换后的表达式和解释说明的元组</p>
      <p><strong>执行流程:</strong></p>
      <ol>
        <li>获取适用于当前表达式的规则列表</li>
        <li>检查规则是否可以应用</li>
        <li>按优先级尝试应用规则</li>
        <li>如果没有规则匹配，回退到 SymPy 的内置计算方法</li>
      </ol>

      <div class="method-signature">
        _check_rule_is_can_apply(self, _rule: RuleFunction) -> bool
      </div>
      <p>
        检查特定规则是否可以应用。默认实现总是返回
        True，子类可以重写此方法以根据特定条件过滤规则。
      </p>

      <h3>4.&nbsp;&nbsp;缓存与性能优化方法</h3>

      <div class="method-signature">
        _get_cached_result(self, expr: Expr, operation: Operation, **context:
        Context) -> Operation
      </div>
      <p>
        获取表达式对应的操作对象（Derivative/Integral等），使用缓存避免重复计算。
      </p>
      <img
        src="/static/images/base_calculator/bc_gcr.svg"
        alt="bc_gcr"
        style="max-width: 100%"
      />

      <div class="method-signature">
        @lru_cache(maxsize=128) _cached_simplify(self, expr: Expr) -> Expr
      </div>
      <p>获得表达式的化简结果，使用 LRU 缓存机制优化性能。</p>

      <h3>5.&nbsp;&nbsp;上下文处理方法</h3>

      <div class="method-signature">
        _context_split(self, **context: Context) -> Symbol
      </div>
      <p>
        从上下文中分离出构建操作对象所需的参数。默认实现仅适合微分、积分计算器，极限和行列式计算器需要重写此方法。
      </p>

      <div class="method-signature">
        _get_context_dict(self, **context: Context) -> RuleContext
      </div>
      <p>将传入的上下文参数转换为规则上下文字典，供规则函数使用。</p>

      <h3>6.&nbsp;&nbsp;表达式处理方法</h3>

      <div class="method-signature">
        _perform_operation(self, expr: Expr, operation: Operation, **context:
        Context) -> Operation
      </div>
      <p>
        将表达式转换成对应的操作对象（Derivative/Integral等）。仅被
        _get_cached_result() 调用。
      </p>

      <div class="method-signature">
        _update_expression(self, current_expr: Expr, operation: Operation,
        expr_to_operation: Dict[Expr, Operation], **context: Context) ->
        Tuple[Expr, str, Dict[Expr, Operation]]
      </div>
      <p>
        在计算过程中更新表达式。应用规则到当前表达式，然后使用 subs 方法更新
        expr_to_operation 字典中所有相关条目。
      </p>

      <h3>7.&nbsp;&nbsp;后处理方法</h3>

      <div class="method-signature">
        @staticmethod _step_expr_postprocess(step_expr: Expr) -> Expr
      </div>
      <p>
        在将步骤表达式添加到步骤生成器之前对其进行后处理。默认情况下直接返回输入表达式，子类可以根据需要重写此方法。
      </p>

      <p><strong>示例:</strong> 在积分计算器中用于添加积分常数。</p>

      <div class="method-signature">
        _final_postprocess(self, final_expr: Expr) -> None
      </div>
      <p>
        对最终计算结果进行后处理。通过假设所有自由符号都是正实数来进行域感知简化。
      </p>

      <p>
        <strong>示例:</strong> 这有助于化简像 ln(1/x) 到 -ln(x) 这样的表达式。
      </p>

      <div class="warning">
        <p>
          <strong>注意:</strong>&nbsp;&nbsp; Sympy 的 simplify()
          采用保守策略，如果不假设 x 为正实数，它不会化简形如 ln(1/x) 的表达式。
        </p>
      </div>

      <h3>8.&nbsp;&nbsp;输出方法</h3>

      <div class="method-signature">
        @abstractmethod compute_list(self, expr: str, **context: Context) ->
        Tuple[List[Expr], List[str]]
      </div>
      <p>计算表达式的逐步求解过程并以元组形式返回结果。</p>
      <p><strong>抽象方法</strong> - 必须在子类中设定计算所需的上下文。</p>
      <p>
        <strong>返回值:</strong> 包含 SymPy 表达式列表和步骤说明字符串列表的元组
      </p>
      <p><strong>适用场景:</strong> 需要程序化访问计算结果的场景</p>

      <div class="method-signature">
        @abstractmethod compute_latex(self, expr: str, **context: Context) ->
        str
      </div>
      <p>计算表达式的逐步求解过程并以 LaTeX 字符串形式返回结果。</p>
      <p><strong>抽象方法</strong> - 必须在子类中设定计算所需的上下文。</p>
      <p>
        <strong>适用场景:</strong> 在 Jupyter Notebook 或网页中渲染数学表达式
      </p>

      <h2 id="subclassing">五.&nbsp;&nbsp;子类化指南</h2>
      <p>创建 BaseCalculator 的子类需要实现以下关键步骤：</p>

      <ul>
        <li>在子类的 init_key_property 方法中务必初始化所有必需属性</li>
        <li>
          在子类的 compute_list 和 compute_latex 方法中务必设定计算的上下文
        </li>
        <li>合理设计规则和匹配器，确保计算过程的正确性和效率</li>
        <li>考虑重写一些方法以实现特定领域所需的操作</li>
      </ul>
      <div class="warning">
        <p>
          <strong>注意:</strong>&nbsp;&nbsp; 可参照已实现的 DiffCalculator,
          IntegralCalculator, LimitCalculator, DetCalculator 类。
        </p>
      </div>
    </div>
  </body>
</html>
